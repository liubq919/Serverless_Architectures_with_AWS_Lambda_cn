#### 卓越运维最佳实践

创建无服务器应用程序消除了传统应用程序带来的许多运维负担。这并不意味着你应该减少对卓越运维的关注。这意味着你可以将操作重点缩小到更少的责任，并有望实现更高级别的卓越运维。

##### 日志

Lambda的每种语言运行时都为函数提供了一种机制，可以将日志语句交付给CloudWatch Logs。对于Lambda和无服务器架构来说，充分使用日志并不是什么新鲜事。尽管今天并不认为这是最佳实践，但是许多运维团队依赖于查看日志，因为日志是在部署应用的服务器上生成的。很显然在Lambda中是不可能的，因为没有服务器。你现在也无法“逐步”执行实时运行的Lambda函数代码（尽管可以在部署之前使用[AWS SAM Local](https://github.com/awslabs/aws-sam-local)执行此操作）。对于已部署的函数，你在很大程度上依赖于创建的日志来指引函数行为的调查。 因此，特别重要的是，创建的日志能够找到详细程度的平衡，以帮助跟踪/诊断问题，而不需要太多额外的计算时间来创建它们。

我们建议你使用Lambda环境变量来创建一个函数可以引用的日志级变量，这样它就可以确定在运行时创建哪些日志语句。适当地使用日志级别可以确保你能够仅在运维诊断期间选择性地产生额外的计算成本和存储成本。

##### 指标与监控

Lambda与其他AWS服务一样，提供了许多开箱即用的CloudWatch指标。这些指标包括与函数接收到的调用次数、函数的执行时间等相关的指标。通过CloudWatch在所有提供的指标上为**每个**Lambda函数创建警报阈值(高阈值和低阈值)是最佳实践。函数调用方式或执行时间的重大更改可能是架构中出现问题的第一个迹象。

对于应用程序需要收集的任何额外指标(例如，应用程序错误代码、特定依赖的延迟等)，有两个选项可以将这些自定义指标存储在CloudWatch或你选择的监视解决方案中：
- 创建一个自定义度量，并在Lambda函数执行时直接与它所需的API集成。这将具有最少的依赖，并将尽可能快地记录指标。但是，它确实需要你花费Lambda执行时间和资源与另一个服务依赖集成。如果遵循此方法，请确保用于捕获指标的代码是模块化的，并可跨Lambda函数复用，而不是与特定的Lambda函数紧密耦合。
- 捕获Lambda函数代码中的指标，并使用Lambda中提供的日志记录机制对其进行日志记录。然后，在函数流上创建一个CloudWatch Logs指标过滤器，以提取指标并使其在CloudWatch中可用。或者，在CloudWatch Logs流上创建另一个Lambda函数作为订阅过滤器，将过滤后的日志语句推送到另一个指标解决方案。该方案引入了更多的复杂性，并且不像之前指标捕获方案那样接近实时。但是，它允许函数通过日志记录而不是发出外部服务请求来更快地创建指标。

##### 部署

在Lambda中执行部署非常简单，只需上传新函数代码包、发布新版本和更新别名即可。但是，这些步骤应仅是Lambda部署过程的一部分。每个部署流程都是特定于应用的。要设计避免对用户或应用程序行为造成负面影响的部署流程，你需要了解每个Lambda函数及其事件源和依赖之间的关系。需要考虑的事情有：
- 并行版本调用 - 更新别名以指向新版本的Lambda函数在服务端是异步发生的。将会有一段很短的时间，包含先前源代码包的现有函数容器将继续与别名已更新到的新函数版本一起调用。在此过程中，应用程序继续按期运行是非常重要的。该方案的一个因素可能是在部署后退役的任何堆栈依赖（例如，数据库表，消息队列等）不能退役，直到你观察到所有的新调用指向了新版本函数。
- 部署计划 - 在高峰流量时间内执行Lambda函数部署可能会导致比预期更多的冷启动时间。你应该始终在低流量时段执行函数部署，以最大限度地减少Lambda环境中配置的新/冷函数容器的直接影响。
- 回滚 - Lambda提供有关Lambda函数版本的详细信息(例如，创建时间、递增数字等)。但是，它没有逻辑地跟踪应用生命周期如何使用这些版本。如果需要回滚Lambda函数代码，那么对于流程来说，回滚到以前部署的函数版本非常重要。

##### 负载测试

负载测试Lambda函数以确定最佳超时值。分析函数的运行时间很重要，这样就可以更好地确定依赖服务的任何问题，这些问题可能会增加超出预期的函数并发性。当Lambda函数对可能无法处理Lambda伸缩的资源进行网络调用时，这一点尤其重要。

##### 诊断和调试

记录日志以允许调查，使用X-Ray剖析应用，两者都有助于运维诊断。另外，考虑创建Lambda函数别名，这些别名表示诸如集成测试、性能测试、调试等运维活动。团队通常构建服务于运维的测试套件或分割的应用程序堆栈。你应该构建这些运维组件，也通过别名与Lambda函数集成。但是，请记住，别名并不强制使用完全独立的Lambda函数容器。因此，像PerfTest这样的别名指向版本N函数，将与指向版本N的所有其他别名使用相同的函数容器。你应该定义合适的版本控制和别名更新流程，以确保在需要时调用独立的容器。
