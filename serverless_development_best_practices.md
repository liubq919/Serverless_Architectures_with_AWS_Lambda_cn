### 无服务器开发最佳实践

使用Lambda创建应用程序可以实现以前从未体验过的开发速度。对于可行且健壮的无服务器应用程序，你需要编写的代码量可能只是基于服务器模型所需编写的代码的一小部分。但是，使用无服务器架构支持的新应用程序交付模型，你的开发流程必须对新的维度和构造进行决策。例如，记住使用Lambda函数组织代码库，将代码更改从开发人员笔记本电脑转移到生产服务器环境中，以及通过测试确保代码质量，即使无法在AWS之外模拟Lambda运行时环境或事件源。以下是一些以开发为中心的最佳实践，可帮助你完成拥有无服务器应用的方方面面。

#### 架构及代码 - AWS服务器应用模型（AWS SAM）

在管理基础设施的创建和修改的可审核性、自动化和可重复性方面，将基础设施表示为代码会带来很多好处。即使在构建无服务器应用时你不需要管理任何基础设施，但许多组件在架构中扮演了一个角色:IAM角色、Lambda函数及其配置、事件源和其他依赖项。在AWS CloudFormation中原生表示所有这些内容需要大量的JSON或YAML。从一个无服务器应用到下一个无服务器应用，大部分内容几乎相同。

AWS无服务器应用模型(AWS SAM)使你能够在构建无服务器应用时获得更简单的体验，并获得架构及代码的好处。[AWS SAM](https://github.com/awslabs/serverless-application-model)是AWS CloudFormation之上的开放规范抽象层。它提供了一组命令行工具，使你能够使用几行JSON或YAML定义完整的无服务器应用堆栈，将Lambda函数代码与其基础设施定义打包在一起，然后将它们一起部署到AWS。我们建议使用AWS SAM与AWS CloudFormation相结合来定义和更改无服务器应用环境。

但是，在基础设施/环境级别发生的更改与现有Lambda函数中发生的应用代码更改之间存在区别。为Lambda函数代码而构建的部署流水线，AWS CloudFormation和AWS SAM并不是其所需的唯一工具。有关管理Lambda函数的代码更改的更多建议，请参阅本白皮书的CI/CD部分。

#### 本地测试 - AWS SAM Local

与AWS SAM一起，[AWS SAM Local](https://github.com/awslabs/aws-sam-cli)提供了其他命令行工具，可以将这些工具添加到AWS SAM，以便在将无服务器函数和应用部署到AWS之前对其进行本地测试。AWS SAM Local使用Docker使你能够使用常用事件源（例如，Amazon S3，DynamoDB等）快速测试开发的Lambda函数。在API网关中创建之前，可以在SAM模板中本地测试定义的API。你还可以验证创建的AWS SAM模板。通过启用这些功能，可以驻留在开发人员工作站中运行Lambda函数，你可以在本地执行诸如查看日志、在调试器中单步执行代码以及快速迭代更改，而无需将新代码包部署到AWS。

#### 代码编写与代码管理最佳实践

在为Lambda函数开发代码时，有一些关于你应该如何编写和组织代码的具体建议，以便管理许多Lambda函数不会成为一项复杂的任务。

##### 代码编写最佳实践

根据使用的Lambda运行时语言，继续遵循为该语言建立的最佳实践。虽然围绕代码调用方式的环境已随Lambda发生了更改, 但语言运行时环境与其他任何地方相同。代码编写标准和最佳实践仍然适用。以下建议是特定于为Lambda编写代码，而不是所选择的语言的一般最佳实践。

###### 业务逻辑在Handler之外

Lambda函数在代码包中定义的处理函数处开始执行。在处理函数中，你应该会接收到Lambda提供的参数，将这些参数传递给另一个函数以解析应用上下文化的新变量/对象，然后转到位于处理函数和文件之外的业务逻辑。这使你能够创建尽可能与Lambda运行时环境解耦的代码包。这将极大地有利于在你所创建的对象和函数的上下文中测试代码的能力，并复用在Lambda之外的其他环境中编写的业务逻辑。

下面的示例(用Java编写)展示了应用程序的核心业务逻辑与Lambda紧密耦合的糟糕实践。在本例中，业务逻辑是在处理程序方法中创建的，并直接依赖于Lambda事件源对象。

![6](images/Figure6.jpg)

###### 容器预热 - 缓存/长连接/复用

如前所述，你应该编写利用预热函数容器的代码。这意味着以一种可能在后续调用中复用变量及其内容的方式确定变量的范围。这对于诸如引导配置、保持外部依赖关系连接的打开，或者可以从一个调用持续到下一个调用的大型对象的一次性初始化等情况尤其有效。

###### 依赖控制

Lambda执行环境包含许多库，例如用于Node.js的AWS SDK和Python运行时。（有关完整列表，请参阅[Lambda执行环境和可用库](https://docs.aws.amazon.com/lambda/latest/dg/current-supported-versions.html)。）为了启用最新的功能和安全更新，Lambda会定期更新这些库。这些更新可能会对Lambda函数的行为进行细微更改。要完全控制函数使用的依赖项，我们建议你使用部署包打包所有依赖项。

###### 依赖修剪

Lambda函数代码包在压缩时最多允许为50MB，在运行时环境中压缩时最多允许为250MB。如果在函数代码中包含大型依赖组件，则可能需要将所包含的依赖项修剪为仅运行时的必需项。这也允许在冷启动时更快地下载和安装Lambda函数代码。

###### 快速失败

为任何外部依赖项配置合理短的超时，以及合理短的总体Lambda函数超时。不要让函数在等待依赖项响应时无助地旋转。因为Lambda是根据函数执行的持续时间计费的，所以当函数依赖无响应时，你不希望产生高于必要的费用。

###### 异常处理

你可能决定根据Lambda的用例以不同的方式抛出和处理异常。如果你在Lambda函数的上游部署了API Gateway API，你可能决定将异常抛回API Gateway，API Gateway会基于发生的错误内容将其转换成合适的HTTP状态码与消息。如果你正在构建一个异步数据处理系统，那么你可能会认为代码库中的一些异常应该等同于将调用移动到死信队列以进行重新处理，而其他错误则可以直接记录下来，而不是放在死信队列中。你应该评估你所决定的失败行为是什么，并确保在代码中你正在创建和抛出正确类型的异常来实现此行为。要了解有关处理异常的更多信息，请参阅以下内容，了解如何为每种语言运行时环境定义异常：
- [Java](https://docs.aws.amazon.com/lambda/latest/dg/java-exceptions.html)
- [Node.js](https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-mode-exceptions.html)
- [Python](https://docs.aws.amazon.com/lambda/latest/dg/python-exceptions.html)
- [C#](https://docs.aws.amazon.com/lambda/latest/dg/dotnet-exceptions.html)

##### 代码管理最佳实践

既然为Lambda函数编写的代码遵循了最佳实践，那么你应该如何管理这些代码呢？使用Lambda所支持的开发速度，你可能能够以典型流程所不熟悉的速度完成代码更改。无服务器架构所需的代码量减少了，这意味着Lambda函数代码代表了构成整个应用堆栈函数的很大一部分内容。因此，对Lambda函数代码进行良好的源代码管理将有助于确保安全、高效和平滑的变更管理流程。

###### 代码仓库组织

我们建议在选择源代码管理解决方案时，以高细粒度的方式组织Lambda函数源代码。这通常意味着Lambda函数和代码仓库或仓库项目（不同的源代码管理工具使用不同的词典。）之间有1:1的关系。但是，如果你遵循的策略是在相同逻辑的函数的不同生命周期阶段创建独立的Lambda函数(也就是说,你有两个Lambda函数,一个叫MyLambdaFunction-DEV和另一个为MyLambdaFunction-PROD)，那么这些独立的Lambda函数分享一个代码库是有意义的（部署可能是基于独立的发布分支）。

以这种方式组织代码的主要目的是帮助确保对特定Lambda函数的代码包作出贡献的所有代码都是独立版本控制和提交的，并定义其自己的依赖和那些依赖版本。每个Lambda函数都应该从源代码的角度与其他Lambda函数完全解耦，就像部署时一样。你不希望将应用架构现代化，使之模块化并与Lambda解耦，那么结果只会留下一个整体的、紧密耦合的代码。

###### 发布分支

我们建议创建仓库或项目分支策略，以便将Lambda函数部署与发布分支上的增量提交相关联。如果你无法自信地将仓库中的源代码更改与已部署到活动Lambda函数中的更改关联起来，那么操作调查总是从尝试确定当前部署的代码版本开始。你应该构建一个CI/CD管道（稍后提供更多建议），允许将Lambda代码包创建和部署时间与该Lambda函数的发布分支所发生的代码更改相关联。

#### 测试

花时间开发代码的全面测试是确保无服务器体系结构中的质量的最佳方法。但是，无服务器架构将执行适当的单元测试实践，可能比你习惯的更多。许多开发人员使用单元测试工具和框架来编写测试，从而使他们的代码也测试其依赖。这是一个结合了单元测试和集成测试的单一测试，但是这两种测试完成地都不是很好。

将所有单元测试用例范围缩小到单个逻辑函数中的单个代码路径，模拟来自上游的所有输入和来自下游的输出，这一点非常重要。这允许将测试用例仅与你拥有的代码隔离。在编写单元测试时，基于代码与api、库等与之间的契约，你可以也应该假设依赖能正确工作。

对于集成测试来说，在模拟现实环境的环境中测试代码与其依赖的集成也同样重要。在开发人员笔记本或者构建服务器上测试与下游依赖的集成，并不能完全测试代码是否能够在现实环境中成功集成一次。这在Lambda环境中尤其如此，在这个环境中，代码没有将由事件源传递的事件的所有权，并且你无法在Lambda之外创建Lambda运行时环境。

###### 单元测试

根据我们之前的说法，我们建议你对Lambda函数代码进行彻底的单元测试，主要关注处理程序函数之外的业务逻辑。还应该单元测试解析函数事件源的样本/模拟对象的能力。但是，大部分逻辑和测试应该使用在代码中你能完全控制的模拟对象和函数。如果觉得处理程序函数中有一些重要的东西需要进行单元测试，那么这可能是你应该在处理程序函数中进一步封装和具体化逻辑的标志。另外，为了补充你编写的单元测试，应该使用AWS SAM Local创建本地测试自动化，它可以作为函数代码的本地端到端测试(注意，这不是单元测试的替代品)。

###### 集成测试

对于集成测试，我们建议你创建Lambda函数的较低生命周期版本，在这个版本中，通过CI/CD管道可以触发和检查的示例事件部署和调用代码包（实现取决于应用和架构）。


#### 持续推送

我们建议您通过CI/CD管道以编程方式管理所有的无服务器部署。这是因为使用Lambda开发新功能和推送代码更改的速度将允许更频繁地部署。手动部署与更频繁部署的需求相结合，常常会导致手动流程成为瓶颈并容易出错。

AWS CodeCommit，AWS CodePipeline，AWS CodeBuild，AWS SAM和AWS CodeStar提供的功能提供了一组特性，你可以将这些特性原生地组合到一个整体和自动化的无服务器CI/CD管道中（管道本身也没有你需要管理的基础设施）。

下面是这些服务在定义良好的持续交付策略中如何发挥作用。

**AWS CodeCommit** - 提供托管的私有Git存储库，使你能够托管无服务器的源代码，创建符合我们建议的分支策略(包括细粒度访问控制)，并与AWS CodePipeline集成，以便在发布分支中发生新的提交时触发新的管道执行。

**AWS CodePipeline** - 定义管道中的步骤。通常，AWS代码管道从源代码更改到达的地方开始。然后执行构建阶段，对新构建执行测试，并将构建部署和发布到现实环境中。AWS CodePipeline为每个阶段提供了与其他AWS服务的原生集成选项。

**AWS CodeBuild** - 可以用于管道的构建状态。使用它来构建代码、执行单元测试和创建新的Lambda代码包。然后，与AWS SAM集成，将代码包推送到Amazon S3，并通过AWS CloudFormation将新包推送到Lambda。
在新版本通过AWS CodeBuild发布到Lambda函数之后，你可以通过创建以部署为中心的Lambda函数来自动化AWS CodePipeline管道中的后续步骤。它们将拥有执行集成测试、更新函数别名、确定是否需要立即回滚以及在应用部署期间需要发生的任何其他以应用为中心的步骤(如缓存刷新、通知消息等)的逻辑。这些以部署为中心的Lambda函数中的每一个都可以被逐次调用，作为使用Invoke动作的AWS CodePipeline管道中的一个步骤。有关在AWS CodePipeline中使用Lambda的详细信息，请参阅[此文档](https://docs.aws.amazon.com/zh_cn/codepipeline/latest/userguide/actions-invoke-lambda-function.html)。

最后，每个应用和组织对于将源代码从仓库迁移到生产环境都有自己的需求。在此过程中引入的自动化程度越高，使用Lambda实现的灵活性就越高

**AWS CodeStar** - 用于创建无服务器应用(和其他类型的应用)的统一用户界面，帮助你从头开始遵循这些最佳实践。在AWS CodeStar中创建新项目时，你将自动开始使用完全实现且集成的持续推送工具链（使用前面提到的AWS CodeCommit，AWS CodePipeline和AWS CodeBuild服务）。你还可以在其中管理项目SDLC的所有方面，包括团队成员管理、问题跟踪、开发、部署和操作。有关AWS CodeStar的更多信息，请访问[这里](https://aws.amazon.com/codestar/)。


